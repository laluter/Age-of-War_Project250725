<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì—­ì‚¬ì˜ ê²©ì „ì§€</title>
  <style>
    canvas { border: 1px solid black; background-color: #fff; }
    button { margin-right: 5px; }

    /*  ë©”ë‰´ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼  */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(210, 180, 140, 0.95); /* ê¸°ì¡´ ë°°ê²½ìƒ‰ ê³„ì—´ì— ì‚´ì§ íˆ¬ëª…ë„ */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .overlay h1 {
      font-size: 4em;
      color: gold;
      text-shadow: 2px 2px 4px #000;
      margin-bottom: 20px;
    }
    .overlay h2 {
      font-size: 2.5em;
      color: #333;
      margin-bottom: 10px;
    }
    .overlay button, .overlay .diff {
      padding: 12px 24px;
      font-size: 1.2em;
      margin: 8px;
      cursor: pointer;
      border: 2px solid #333;
      background: #fff;
      border-radius: 6px;
    }
    .overlay a {
      margin-top: 20px;
      color: #333;
      text-decoration: underline;
      cursor: pointer;
    }

    #hud {
      position: absolute;            /* ìˆ˜ì •: í™”ë©´ ìµœìƒë‹¨ ê³ ì • */
      top: 10px;                     /* ìˆ˜ì •: ìƒë‹¨ ë§ˆì§„ */
      left: 50%;                     /* ìˆ˜ì •: ê°€ë¡œ ê°€ìš´ë° ì •ë ¬ */
      transform: translateX(-50%);   /* ìˆ˜ì •: ì •í™•íˆ ì¤‘ì•™ */
      width: 95%;                    /* ìˆ˜ì •: í™”ë©´ ë„ˆë¹„ì— ë§ì¶¤ */
      display: flex;
      flex-direction: column;        /* ìˆ˜ì •: 3í–‰ êµ¬ì¡° */
      gap: 8px;                      /* ìˆ˜ì •: ìš”ì†Œ ê°„ê²© */
      background: rgba(210,180,140,0.8);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      z-index: 100;
      font-family: 'ë§‘ì€ ê³ ë”•', sans-serif;
    }

    /* ìˆ˜ì •: ê¸°ì§€ ì²´ë ¥ë°” ì»¨í…Œì´ë„ˆ */
    .base-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .bar-bg {
      flex: 1;
      height: 12px;
      background: #ccc;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }
    .bar-fill {
      height: 100%;
      background: green;
      width: 100%;                   /* JS updateHUD()ë¡œ ê°±ì‹  */
      transition: width 0.2s ease;
    }
    .bar-fill.enemy {
      background: red;
    }

    /* ìˆ˜ì •: ìœ ë‹›Â·íƒ€ì›Œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .hud-btn {
      background: #fff;
      border: 2px solid #333;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.2s;
      position: relative;
    }
    .hud-btn:hover {
      background: #f0e0b0;
    }

    /* â€”â€”â€” 4) ë±ƒì§€ ìŠ¤íƒ€ì¼ â€”â€”â€” */
    .hud-btn .badge {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #c00;
      color: #fff;
      border-radius: 50%;
      padding: 4px 8px;      /* â†‘ ë” í¬ê²Œ */
      font-size: 0.9em;      /* â†‘ í‚¤ì›Œì„œ ì˜ ë³´ì´ê²Œ */
      min-width: 1.4em;      /* ìˆ«ìê°€ 2ìë¦¬ì—¬ë„ ì˜ë¦½ë‹ˆë‹¤. */
      text-align: center;
      pointer-events: none;
    }

    /* â€”â€”â€” 1) ì˜¤ë²„ë ˆì´ ì¿¨ë‹¤ìš´ â€”â€”â€” */
    .hud-btn .btn-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      transform-origin: top;
      transform: scaleY(0);
      transition: transform 0.1s linear;
      pointer-events: none;
    }
    /* ì¿¨ë‹¤ìš´ ì¤‘ì¼ ë•Œ ì˜¤ë²„ë ˆì´ ë¹„ìœ¨ ì ìš© */
    .hud-btn.cooling .btn-overlay {
      transform: scaleY(var(--cd-ratio, 0));
    }
    /* ë‚¨ì€ ì‹œê°„ í…ìŠ¤íŠ¸ í‘œì‹œ */
    .hud-btn.cooling::after {
      content: attr(data-remaining) 's';
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #333;
      font-size: 0.9em;
      pointer-events: none;
    }

    /* ìˆ˜ì •: ìì›Â·ìƒíƒœ í…ìŠ¤íŠ¸ */
    .stats {
      display: flex;
      gap: 12px;
      font-weight: bold;
      color: #333;
    }

    /* ìˆ˜ì •: í˜ì´ì§€ ì—¬ë°± ì œê±° */
    body, #game {
      margin: 0;
      padding: 0;
    }

    
  </style>
</head>
<body style="background-color: #d2b48c; position: relative;">

  <div id="game" style="position: relative; width:1900px; margin:0 auto;">

    <!-- ìˆ˜ì •: HUD ì˜ì—­ (canvas ìœ„ë¡œ ì´ë™) -->
    <div id="hud" style="display: none;">
      <!-- ê¸°ì§€ ì²´ë ¥ë°” -->
      <div class="base-bar-container">
        <span>ğŸ° ë‚´ ê¸°ì§€</span>
        <div class="bar-bg"><div id="playerBaseBar" class="bar-fill"></div></div>
        <span>ì  ê¸°ì§€ ğŸ¯</span>
        <div class="bar-bg"><div id="enemyBaseBar" class="bar-fill enemy"></div></div>

        <!-- ì˜ˆì•½ ìƒì‚° í˜„í™© í‘œì‹œ -->
        <div id="productionQueueDisplay" class="stats" style="font-size:0.9em; gap:6px;">
          ì˜ˆì•½ìƒì‚° â–¶ <span id="queueDisplayText">ì—†ìŒ</span>
        </div>
      </div>

      <!-- ìœ ë‹›Â·íƒ€ì›Œ ì»¨íŠ¸ë¡¤ -->
    <div class="controls">
      <!-- ê·¼ì ‘ ìœ ë‹› -->
      <button id="btnSpawnMelee" class="hud-btn">
        ê·¼ì ‘ ìœ ë‹›
        <span class="badge">0</span>
        <div class="btn-overlay"></div>
      </button>

      <!-- ì›ê±°ë¦¬ ìœ ë‹› -->
      <button id="btnSpawnRanged" class="hud-btn">
        ì›ê±°ë¦¬ ìœ ë‹›
        <span class="badge">0</span>
        <div class="btn-overlay"></div>
      </button>

      <!-- ì—˜ë¦¬íŠ¸ ìœ ë‹› -->
      <button id="btnSpawnElite" class="hud-btn">
        ì—˜ë¦¬íŠ¸ ìœ ë‹›
        <span class="badge">0</span>
        <div class="btn-overlay"></div>
      </button>

      <!-- ìŠ¤í˜ì…œ ìœ ë‹› (ë¯¸ë˜ ì‹œëŒ€ë§Œ í™œì„±í™”) -->
      <button id="btnSpawnSpecial" class="hud-btn">
        ìŠ¤í˜ì…œ ìœ ë‹›
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>

      <!-- íƒ€ì›Œ ì„¤ì¹˜ -->
      <button id="btnBuildTower" class="hud-btn">
        íƒ€ì›Œ ì„¤ì¹˜
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>

      <!-- íƒ€ì›Œ ì—…ê·¸ë ˆì´ë“œ -->
      <button id="btnUpgradeTower" class="hud-btn">
        íƒ€ì›Œ ì—…ê·¸ë ˆì´ë“œ
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>

      <!-- íƒ€ì›Œ í•´ì²´ (ë§ˆì§€ë§‰ ì„¤ì¹˜, 70% í™˜ê¸‰) -->
      <button id="btnSellTower" class="hud-btn">
        íƒ€ì›Œ í•´ì²´<br>(ë§ˆì§€ë§‰ ì„¤ì¹˜, 70% í™˜ê¸‰)
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>

      <!-- ìŠ¤í‚¬ 1 -->
      <button id="skill1Btn" class="hud-btn">
        ìŠ¤í‚¬ 1
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>

      <!-- ìŠ¤í‚¬ 2 -->
      <button id="skill2Btn" class="hud-btn">
        ìŠ¤í‚¬ 2
        <span class="badge"></span>
        <div class="btn-overlay"></div>
      </button>
    </div>


      <!-- ê³¨ë“œÂ·ê²½í—˜ì¹˜ -->
      <div class="stats">
        <span id="goldDisplay">ê³¨ë“œ: 500</span>
        <span id="expDisplay">ê²½í—˜ì¹˜: 0</span>
        <span id="baseDisplay">ë‚´ ê¸°ì§€ ì²´ë ¥: 500 | ì  ê¸°ì§€ ì²´ë ¥: 500</span>
      </div>
    </div>
    <!-- ìˆ˜ì • ë -->

    <!-- ê¸°ì¡´ ìº”ë²„ìŠ¤ (ìœ„ì¹˜ ë³€ê²½ ì—†ìŒ) -->
    <canvas id="gameCanvas" width="1900" height="800"></canvas>

  <!-- â‘  ë©”ì¸ ë©”ë‰´ ì˜¤ë²„ë ˆì´ -->
  <div id="menuScreen" class="overlay">
    <h1>ì—­ì‚¬ì˜ ê²©ì „ì§€</h1>
    <button id="btnPlay">í”Œë ˆì´</button>
    <button id="btnInstructions">ê²Œì„ ì„¤ëª…</button>
    <button id="btnExtras">ì„¤ì •</button>
    <button id="btnMoreGames">ë” ë§ì€ ê²Œì„ í”Œë ˆì´ í•´ë³´ê¸°</button>
    <div style="position:absolute; bottom:20px; font-size:0.8em; color:#333;">A game by laluter</div>
  </div>

  <!-- â‘¡ ë‚œì´ë„ ì„ íƒ ì˜¤ë²„ë ˆì´ (ê¸°ë³¸ ìˆ¨ê¹€) -->
  <div id="difficultyScreen" class="overlay" style="display:none">
    <h2>ë‚œì´ë„</h2>
    <p>ì‹œì‘ ì „ì— ë‚œì´ë„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”</p>
    <button class="diff" data-level="easy">EASY</button>
    <button class="diff" data-level="normal">NORMAL</button>
    <button class="diff" data-level="hard">HARD</button>
    <a id="btnBack">ë’¤ë¡œê°€ê¸°</a>
  </div>



  <audio id="eraSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  <audio id="towerFireSound-medieval" src="https://actions.google.com/sounds/v1/impacts/wood_plank_flicks.ogg"></audio>
  <audio id="towerFireSound-modern" src="https://actions.google.com/sounds/v1/weapons/medium_machine_gun_single_shot.ogg"></audio>
  <audio id="towerFireSound-future" src="https://actions.google.com/sounds/v1/sci-fi/sci_fi_laser_1.ogg"></audio>
  <audio id="unitAttackSound" src="https://actions.google.com/sounds/v1/impacts/punch_medium.ogg"></audio>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const btnSpawnMelee   = document.getElementById('btnSpawnMelee');
    const btnSpawnRanged  = document.getElementById('btnSpawnRanged');
    const btnSpawnElite   = document.getElementById('btnSpawnElite');
    const btnSpawnSpecial = document.getElementById('btnSpawnSpecial');
    const btnBuildTower   = document.getElementById('btnBuildTower');
    const btnUpgradeTower = document.getElementById('btnUpgradeTower');
    const btnSellTower    = document.getElementById('btnSellTower');  
    const skill1Btn       = document.getElementById('skill1Btn');
    const skill2Btn       = document.getElementById('skill2Btn');
    const units = [];
    const towers = [];
    const enemyTowers = [];
    let gold = 500;
    let exp = 0;
    let currentEra = 'medieval';
    let enemySpawnInterval;
    let attackLines = [];

    btnSpawnMelee  .addEventListener('click', () => spawnUnit('melee'));
    btnSpawnRanged .addEventListener('click', () => spawnUnit('ranged'));
    btnSpawnElite  .addEventListener('click', () => spawnUnit('elite'));
    btnSpawnSpecial.addEventListener('click', () => spawnSpecialUnit());
    btnBuildTower  .addEventListener('click', () => buildTower());
    btnUpgradeTower.addEventListener('click', () => upgradeTower());
    btnSellTower   .addEventListener('click', () => sellTower(towers.length - 1));

    const skillEffects = [];
    // Time Warp ì‹œ ì´ë™Â·ê³µê²© ì†ë„ ë°°ìœ¨
    const SLOW_FACTOR  = 0.5;

    const fireSounds = {
      medieval: document.getElementById("towerFireSound-medieval"),
      modern: document.getElementById("towerFireSound-modern"),
      future: document.getElementById("towerFireSound-future")
    };
    const unitAttackSound = document.getElementById("unitAttackSound");
    const eraSound = document.getElementById("eraSound");

    // â”€â”€ ìœ ë‹› ìƒì‚° í & ìƒì‚° ì‹œê°„ ì„¤ì • â”€â”€
    const productionQueue = [];           // { type, remaining(ms) } ê°ì²´ë¥¼ ìˆœì„œëŒ€ë¡œ ë³´ê´€
    const MAX_QUEUE_SIZE   = 5;

    // ê° ì‹œëŒ€(Unit ìƒì‚° ì‹œê°„: ì´ˆ)
    const productionTime = {
      medieval: {
        melee: 2,    
        ranged: 3,   
        elite: 5     
       
      },
      modern: {
        melee: 3,    
        ranged: 4,   
        elite: 6     
      },
      future: {
        melee: 4,    
        ranged: 5,  
        elite: 7,    
        special: 7.5  
      }
    };

    // í”„ë ˆì„ ê°„ ì‹œê°„ ê³„ì‚°ìš©
    let lastFrameTime = performance.now();

    let playerBaseHp = 500;
    let enemyBaseHp = 500;

    const towerStats = {
      medieval: { range: 200, damage: 5, cost: 100, color: 'saddlebrown' },
      modern: { range: 250, damage: 15, cost: 200, color: 'darkgreen' },
      future: { range: 300, damage: 30, cost: 400, color: 'magenta' }
    };

    const towerLimit = 3;

    const expTable = {
      medieval: { melee: 10, ranged: 15, elite: 25 },
      modern: { melee: 20, ranged: 30, elite: 40 },
      future: { melee: 30, ranged: 40, elite: 50, special: 70 }
    };

    const goldRewardTable = {
      melee: 25,
      ranged: 35,
      elite: 50,
      special: 80
    };    

    const eraUpgradeExp = { medieval: 500, modern: 1000 };
    const baseHpTable = { medieval: 500, modern: 700, future: 900 };
    const eraBackgrounds = {
      medieval: '#d2b48c', modern: '#c0c0c0', future: '#222831'
    };

    document.addEventListener('click', () => {
      unitAttackSound.play().catch(() => {});
    });

    
    function drawHealthBar(x, y, hp, maxHp) {
        const width = 40;
        const height = 6;
        ctx.fillStyle = "#ccc";
        ctx.fillRect(x, y, width, height);
        ctx.fillStyle = "lime";
        ctx.fillRect(x, y, (hp / maxHp) * width, height);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(x, y, width, height);
    }

    function drawAttackLine(x1, y1, x2, y2) {
      attackLines.push({ x1, y1, x2, y2, ttl: 5 });
    }    

    const unitTypes = {
      medieval: {
        melee: { hp: 100, speed: 1, damage: 10, cost: 50, color: 'brown', range: 20 },
        ranged: { hp: 80, speed: 1, damage: 15, cost: 70, color: 'orange', range: 120 },
        elite: { hp: 150, speed: 1, damage: 25, cost: 120, color: 'red', range: 20 }
      },
      modern: {
        melee: { hp: 120, speed: 1.2, damage: 15, cost: 60, color: 'gray', range: 20 },
        ranged: { hp: 100, speed: 1.1, damage: 20, cost: 90, color: 'blue', range: 130 },
        elite: { hp: 180, speed: 1.2, damage: 30, cost: 150, color: 'darkblue', range: 20 }
      },
      future: {
        melee: { hp: 140, speed: 1.4, damage: 20, cost: 80, color: 'purple', range: 20 },
        ranged: { hp: 120, speed: 1.3, damage: 25, cost: 110, color: 'cyan', range: 150 },
        elite: { hp: 200, speed: 1.5, damage: 40, cost: 180, color: 'black', range: 20 },
        special: { hp: 300, speed: 1.6, damage: 60, cost: 300, color: 'gold', range: 180 }
      }
    };

    class Unit {
      constructor(x, team, type, stats) {
        this.x = x;
        this.y = canvas.height - 100;
        this.team = team;
        this.type = type;
        this.hp = stats.hp;
        this.maxHp = stats.hp;
        this.speed = stats.speed;
        this.damage = stats.damage;
        this.color = stats.color;
        this.range = stats.range || 20;
        this.cooldown = 0;   
        this.baseAttackCooldown = 0;
      }
      move() {
        this.x += this.team === 'player' ? this.speed : -this.speed;
      }
      attack(target) {
        target.hp -= this.damage;
         unitAttackSound.currentTime = 0;
         unitAttackSound.play();
         drawAttackLine(this.x + 10, this.y + 10, target.x + 10, target.y + 10);
      }
    
      canAttack(target) {
        const dist = Math.abs(this.x - target.x);
        return this.team !== target.team && dist <= this.range;
      }     
    }
    
    // 1) ìƒ‰ìƒ ë§¤í•‘ í…Œì´ë¸” ì¶”ê°€
    const towerColors = {
      medieval: ['saddlebrown', 'peru', 'sienna'],
      modern:   ['darkgreen', 'limegreen', 'lightgreen'],
      future:   ['magenta', 'violet', 'plum']
    };

    class Tower {
      constructor(x, stats, era, team) {
        this.x = x;
        this.range = stats.range;
        this.damage = stats.damage;
        this.color = stats.color;
        this.era = era;
        this.level = 0;
        this.cooldown = 0;
        this.team = team;
        this.costSpent = stats.cost;
        this.color     = towerColors[era][0];
      }
      attack(units) {

        // skillEffects ëŠ” ì „ì—­ ë°°ì—´ë¡œ, Overwatch ë²„í”„ê°€ ë“¤ì–´ ìˆìŠµë‹ˆë‹¤.
        const ow = skillEffects.find(e => e.type === 'overwatch');
        // ì˜¤ë²„ì›Œì¹˜ê°€ ìˆìœ¼ë©´ ê³µê²©ë ¥Ã—multiplier, ì‚¬ê±°ë¦¬+extraRange
        const dmg = ow ? this.damage * ow.multiplier : this.damage;
        const rng = ow ? this.range + ow.extraRange : this.range;

        if (this.cooldown > 0) {
          this.cooldown--;
          return;
        }
        for (let unit of units) {
          // ì‚¬ê±°ë¦¬(rng) ëŒ€ì‹  this.range, ê³µê²©ë ¥(dmg) ëŒ€ì‹  this.damage ì‚¬ìš©
          if ((this.team === 'player' && unit.team === 'enemy' && unit.x >= this.x && unit.x <= this.x + rng) ||
              (this.team === 'enemy'  && unit.team === 'player' && unit.x <= this.x && unit.x >= this.x - rng)
          ) {
            unit.hp -= dmg;
            fireSounds[this.era].currentTime = 0;
            fireSounds[this.era].play();
            this.cooldown = 30;
            // ì´í™íŠ¸ ì„  ê·¸ë¦¬ê¸°ì—ë„ ì´.color ë“± ê·¸ëŒ€ë¡œ ì‚¬ìš©
            const towerY = canvas.height - 150;
            ctx.beginPath();
            ctx.moveTo(this.x + 5, towerY);
            ctx.lineTo(unit.x + 10, unit.y + 10);
            ctx.strokeStyle = this.color;
            ctx.stroke();
            break;
          }
        }
      }
      upgrade(upgradeCost) {
        if (this.level >= 2) return false;
        this.level++;
        this.damage += 5;
        this.range += 20;
        this.costSpent += upgradeCost;
        this.color      = towerColors[this.era][this.level];
        return true;
      }
    }

    function buildTower() {
      if (towers.length >= towerLimit) return;
      const stats = towerStats[currentEra];
      if (gold >= stats.cost) {
        const x = 40 + towers.length * 15;
        towers.push(new Tower(x, stats, currentEra, "player"));
        gold -= stats.cost;
        updateHUD();
      }
    }

    function upgradeTower() {
      for (let tower of towers) {
        if (tower.level < 2) {
    
          // ê° íƒ€ì›Œê°€ ì§€ì–´ì§„ ì‹œëŒ€ ê¸°ì¤€ìœ¼ë¡œ ë¹„ìš©ì„ êº¼ëƒ…ë‹ˆë‹¤
          const baseCost = towerStats[tower.era].cost;
          const upgradeCost = Math.floor(
            baseCost * (tower.level === 0 ? 1.5 : 2.5)
          );
          if (gold >= upgradeCost && tower.upgrade(upgradeCost)) {
            gold -= upgradeCost;
            updateHUD();
          }
          break;
        }
      }
    }

    /**
    * ê°œë³„ íƒ€ì›Œ í•´ì²´
    * @param {number} idx towers ë°°ì—´ì—ì„œ ì œê±°í•  ì¸ë±ìŠ¤
    */
    function sellTower(idx) {
      if (typeof idx !== 'number' || idx < 0 || idx >= towers.length) {
        alert('í•´ì²´í•  íƒ€ì›Œê°€ ì—†ìŠµë‹ˆë‹¤!');
        return;
      }
      const tower = towers[idx];
      const refund = Math.floor(tower.costSpent * 0.7);
      gold += refund;
      towers.splice(idx, 1);
      updateHUD();
    }

    // 2) ìº”ë²„ìŠ¤ í´ë¦­ìœ¼ë¡œ íƒ€ì›Œ í´ë¦­ ê°ì§€ â†’ ê°œë³„ í•´ì²´
    canvas.addEventListener('click', e => {
      const rect   = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      const towerY = canvas.height - 150;
      const w = 10, h = 50;

      // ë§¨ ìœ„ì— ê·¸ë ¤ì§„ íƒ€ì›Œë¶€í„° ê²€ì‚¬
      for (let i = towers.length - 1; i >= 0; i--) {
        const t = towers[i];
        if (
          clickX >= t.x && clickX <= t.x + w &&
          clickY >= towerY && clickY <= towerY + h
        ) {
          if (confirm(`ì´ íƒ€ì›Œë¥¼ í•´ì²´í•˜ê³  ${Math.floor(t.costSpent*0.7)} ê³¨ë“œë¥¼ íšŒìˆ˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
            sellTower(i);
          }
          break;
        }
      }
    });




    function spawnUnit(type) {
      const stats = unitTypes[currentEra][type];
      // í ìµœëŒ€ 5ê°œ ì œí•œ
      if (productionQueue.length >= MAX_QUEUE_SIZE) {
        return alert('ìµœëŒ€ 5ê°œê¹Œì§€ ìƒì‚° ì˜ˆì•½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      }
      if (gold < stats.cost) {
        return alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
      }

      // ê³¨ë“œ ì¦‰ì‹œ ì°¨ê° & íì— ë‚¨ì€ ì‹œê°„(ms) ìœ¼ë¡œ í‘¸ì‹œ
      gold -= stats.cost;
      productionQueue.push({
        type,
        remaining: productionTime[currentEra][type] * 1000
      });
      updateHUD();
      updateQueueBadges();
    }

    function spawnSpecialUnit() {
      if (currentEra !== 'future') {
        return alert('ë¯¸ë˜ ì‹œëŒ€ì—ë§Œ ìŠ¤í˜ì…œ ìœ ë‹›ì„ ì˜ˆì•½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      }
      const stats = unitTypes.future.special;
      // í ìµœëŒ€ 5ê°œ ì œí•œ
      if (productionQueue.length >= MAX_QUEUE_SIZE) {
        return alert('ìµœëŒ€ 5ê°œê¹Œì§€ ìƒì‚° ì˜ˆì•½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      }
      if (gold < stats.cost) {
        return alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
      }
      gold -= stats.cost;
      productionQueue.push({
        type: 'special',
        remaining: productionTime.future.special * 1000
      });
      updateHUD();
      updateQueueBadges();
    }

    function spawnEnemyUnit() {
      const types = ['melee', 'ranged', 'elite'];
      const randomType = types[Math.floor(Math.random() * types.length)];
      const stats = unitTypes[currentEra][randomType];
      units.push(new Unit(canvas.width - 20, 'enemy', randomType, stats));
    }

    /** 
     * ìƒì‚° íì— ë‹´ê¸´ ê° íƒ€ì…ë³„ ì˜ˆì•½ ê°œìˆ˜ë¥¼ ë±ƒì§€ì— í‘œì‹œ 
     */
    function updateQueueBadges() {
      // 1) productionQueue ì—ì„œ ê°ê° ëª‡ ê°œì”© ìˆëŠ”ì§€ ì§‘ê³„
      const counts = { melee:0, ranged:0, elite:0, special:0 };
      productionQueue.forEach(item => {
        if (counts[item.type] !== undefined) counts[item.type]++;
      });

      // 2) ê° ë²„íŠ¼ .badge ì— ë°˜ì˜
      btnSpawnMelee  .querySelector('.badge').innerText = counts.melee  || '';
      btnSpawnRanged .querySelector('.badge').innerText = counts.ranged || '';
      btnSpawnElite  .querySelector('.badge').innerText = counts.elite  || '';
      // special ì€ ë¯¸ë˜ ì‹œëŒ€ì—ë§Œ í‘œì‹œ
      btnSpawnSpecial.querySelector('.badge').innerText =
        (currentEra === 'future' ? counts.special : '');

      const queueInfo = productionQueue
        .map(i => `${i.type}:${Math.ceil(i.remaining/1000)}s`)
        .join(' | ');
      document.getElementById('queueDisplayText').innerText = queueInfo || 'ì—†ìŒ';
    }

    function unitsOverlap(unitA, unitB) {
      // ìœ ë‹› í¬ê¸°: 20x20, yì¢Œí‘œëŠ” ëª¨ë‘ 300ì´ë¯€ë¡œ xë§Œ ë¹„êµ
      return Math.abs(unitA.x - unitB.x) < 20;
    }
  
    function setDifficulty(level) {
      if (enemySpawnInterval) clearInterval(enemySpawnInterval);
      let interval;
      if (level === 'easy') interval = 3000;
      else if (level === 'normal') interval = 2500;
      else if (level === 'hard') interval = 2000;
      enemySpawnInterval = setInterval(() => {
        spawnEnemyUnit();
        if (enemyTowers.length < towerLimit) {
          const stats = towerStats[currentEra];
          const x = canvas.width - 60 - enemyTowers.length * 15;
          enemyTowers.push(new Tower(x, stats, currentEra, "enemy"));
        }
      }, interval);
    }


    // 2-1) ìŠ¤í‚¬ë³„ ì‹¤í–‰ í•¨ìˆ˜ ë¯¸ë¦¬ ì •ì˜
    function activateIronWall() {
      const duration = 10000; // ms
      const baseWidth = 30;                   // HUDì—ì„œ ì„¤ì •í•œ ë‚´ ê¸°ì§€ í­
      const offset    = 10;                   // ê¸°ì§€ ë°”ë¡œ ì˜†ìœ¼ë¡œ ì‚´ì§
      const x = baseWidth + offset;           // ì•„êµ° ê¸°ì§€ ì˜¤ë¥¸ìª½ì— ë°°ì¹˜
      const y = canvas.height - 150;          // ê¸°ì¡´ y ìœ„ì¹˜ ê·¸ëŒ€ë¡œ

      skillEffects.push({
        type: 'ironWall',
        x, y,
        w: 20, h: 100,
        expireAt: performance.now() + duration,
        ttl: duration
      });
    }
    function activateMedEvac() {
      // ì•„êµ° ìœ ë‹› 30%, ê¸°ì§€ 100 íšŒë³µ
      units.forEach(u => {
        if (u.team==='player') {
          u.hp = Math.min(u.maxHp, u.hp + u.maxHp * 0.3);
        }
      });
      playerBaseHp = Math.min(baseHpTable[currentEra], playerBaseHp + 100);
      updateHUD();
    }
    function activateRapidReinforce() {
      ['melee','ranged','elite'].forEach(type => {
        const stats = unitTypes[currentEra][type];
        // 1ê¸°ì”© ë°˜ë³µ
        for (let i = 0; i < 1; i++) {
          units.push(new Unit(0, 'player', type, stats));
        }
      });
    }
    function activateOverwatch() {
      const duration = 8000;
      skillEffects.push({
        type: 'overwatch',
        multiplier: 2.0, // ê³µê²©ë ¥ 2ë°°
        extraRange: 20,
        expireAt: performance.now() + duration,
        ttl: duration
      });
    }

    function activateTimeWarp() {
      const duration = 5000;
      skillEffects.push({
        type: 'timeWarp',
        expireAt: performance.now() + duration,
        ttl: duration
      });
    }

    function activateEraBlast() {
      // ëª¨ë“  ì  ìœ ë‹›ì—ê²Œ maxHpì˜ 80% í”¼í•´
      units.forEach(u => {
        if (u.team === 'enemy') {
          const dmg = Math.floor(u.maxHp * 0.8);
          u.hp -= dmg;
        }
      });

      // (ì„ íƒ) ê°„ë‹¨í•œ ë¹„ì£¼ì–¼ ì´í™íŠ¸: í™”ë©´ ì¤‘ì•™ì—ì„œ ì§§ê²Œ
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const duration = 500; // ì´í™íŠ¸ ì§€ì†(ms)
      skillEffects.push({
        type: 'eraBlast',
        x: cx, y: cy,
        radius: Math.max(canvas.width, canvas.height),
        expireAt: performance.now() + duration,
        ttl: duration
      });
    }

    // 2-2) ì‹œëŒ€ë³„ë¡œ 2ê°œì”© ìŠ¤í‚¬ ë§¤í•‘
    const skillsByEra = {
      medieval: [
        { label: 'Iron Wall',    cost:150, cd:40, fn: activateIronWall },
        { label: 'Med Evac',     cost:200, cd:60, fn: activateMedEvac    }
      ],
      modern: [
        { label: 'Rapid Reinforce', cost:250, cd:50, fn: activateRapidReinforce },
        { label: 'Overwatch',       cost:300, cd:45, fn: activateOverwatch       }
      ],
      future: [
        { label: 'Time Warp',    cost:350, cd:30, fn: activateTimeWarp  },
        { label: 'Era Blast',    cost:500, cd:120, fn: activateEraBlast  }
      ]
    };

    // 2-3) í˜„ì¬ ë²„íŠ¼ ì„¸íŒ… í•¨ìˆ˜
    function configureSkillButtons() {
      const eraSkills = skillsByEra[currentEra];
      [skill1Btn, skill2Btn].forEach((btn, i) => {
        const sk = eraSkills[i];
        btn.innerText = `${sk.label} (${sk.cost}G)`;         // ë ˆì´ë¸” + ë¹„ìš©
        btn.disabled  = false;                              // í™œì„±í™”
        btn.onclick   = () => tryUseSkill(sk, btn);         // í´ë¦­ ì‹œ ì‹œë„
      });
    }

    // 2-4) ìŠ¤í‚¬ ì‚¬ìš© ì‹œë„ í•¨ìˆ˜
    function tryUseSkill(skill, btn) {
      if (gold < skill.cost) return alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
      if (btn.disabled) return;

      gold -= skill.cost;
      updateHUD();
      skill.fn();

      // 1) ë²„íŠ¼ ë¹„í™œì„±í™” & í´ë˜ìŠ¤ ì¶”ê°€
      btn.disabled = true;
      btn.classList.add('cooling');

      // 2) ë‚¨ì€ ì‹œê°„(ms) ê´€ë¦¬
      let rem = skill.cd;       // ì´ˆ ë‹¨ìœ„
      btn.dataset.remaining = rem.toFixed(0);
      btn.style.setProperty('--cd-ratio', '1');

      const intervalId = setInterval(() => {
        rem -= 1;
        if (rem <= 0) {
          clearInterval(intervalId);
          btn.disabled = false;
          btn.classList.remove('cooling');
          btn.removeAttribute('data-remaining');
        } else {
          // ë‚¨ì€ë¹„ìœ¨ ê³„ì‚°
          const ratio = (rem / skill.cd).toFixed(2);
          btn.style.setProperty('--cd-ratio', ratio);
          btn.dataset.remaining = rem.toFixed(0);
        }
      }, 1000);
    }



    function updateHUD() {
      document.getElementById("playerBaseBar").style.width = (playerBaseHp / baseHpTable[currentEra] * 100) + "%";
      document.getElementById("enemyBaseBar").style.width = (enemyBaseHp / baseHpTable[currentEra] * 100) + "%";
      document.getElementById("goldDisplay").innerText = `ê³¨ë“œ: ${gold}`;
      document.getElementById("expDisplay").innerText = `ê²½í—˜ì¹˜: ${exp}`;
      document.getElementById("baseDisplay").innerText = `ë‚´ ê¸°ì§€ ì²´ë ¥: ${playerBaseHp} | ì  ê¸°ì§€ ì²´ë ¥: ${enemyBaseHp}`;

      const queueInfo = productionQueue
        .map(item => `${item.type}:${Math.ceil(item.remaining/1000)}s`)
        .join(' | ');
      document.getElementById('expDisplay').title = queueInfo || 'ìƒì‚° ì˜ˆì•½ ì—†ìŒ';

      configureTooltips();
      updateQueueBadges();    // â† HUDê°€ ë°”ë€” ë•Œë§ˆë‹¤ ë±ƒì§€ ë™ê¸°í™”
    }

    function renderUnits() {
      units.forEach(unit => {
        ctx.fillStyle = unit.color;
        ctx.fillRect(unit.x, unit.y, 20, 20);
        drawHealthBar(unit.x, unit.y - 10, unit.hp, unit.maxHp);
      });
    }

    function renderAttackLines() {
      attackLines = attackLines.filter(line => {
        ctx.beginPath();
        ctx.moveTo(line.x1, line.y1);
        ctx.lineTo(line.x2, line.y2);
        ctx.strokeStyle = "red";
        ctx.stroke();
        line.ttl--;
        return line.ttl > 0;
      });
    }

    function tryEraUpgrade() {
      if (currentEra === 'medieval' && exp >= eraUpgradeExp.medieval) {
        currentEra = 'modern';
      }
      else if (currentEra === 'modern' && exp >= eraUpgradeExp.modern) {
        currentEra = 'future';
      }
      else return;

      // ê¸°ì§€ ì²´ë ¥Â·ë°°ê²½ ë¦¬ì…‹
      playerBaseHp = baseHpTable[currentEra];
      enemyBaseHp  = baseHpTable[currentEra];
      document.body.style.backgroundColor = eraBackgrounds[currentEra];
      eraSound.play();
      updateHUD();

      configureSkillButtons();
      configureTooltips();
    }

    // (1) ë‹¤ìŒ ì—…ê·¸ë ˆì´ë“œ ë¹„ìš© ê³„ì‚° í—¬í¼
    function getNextUpgradeCost() {
      for (let tower of towers) {
        if (tower.level < 2) {
          // ê¸°ì¡´ íƒ€ì›Œì˜ era ê¸°ì¤€ ë¹„ìš©
          const base = towerStats[tower.era].cost;
          const mult = tower.level === 0 ? 1.5 : 2.5;
          return Math.floor(base * mult);
        }
      }
      return 0; // ì—…ê·¸ë ˆì´ë“œ ëŒ€ìƒì´ ì—†ë‹¤ë©´ 0
    }


    // (2) íˆ´íŒ(title) ì„¸íŒ… í•¨ìˆ˜
    function configureTooltips() {
      // ë‹¨, ì´ ìš”ì†Œë“¤ì€ DOMì—ì„œ ì´ë¯¸ querySelector/ getElementById í•´ ë‘ì…¨ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.
      btnSpawnMelee   .title = `ê³¨ë“œ: ${unitTypes[currentEra].melee.cost}`;
      btnSpawnRanged  .title = `ê³¨ë“œ: ${unitTypes[currentEra].ranged.cost}`;
      btnSpawnElite   .title = `ê³¨ë“œ: ${unitTypes[currentEra].elite.cost}`;
      btnSpawnSpecial .title = currentEra === 'future'
        ? `ê³¨ë“œ: ${unitTypes.future.special.cost}`
        : 'ë¯¸ë˜ ì‹œëŒ€ì—ë§Œ ê°€ëŠ¥';

      btnBuildTower   .title = `ê³¨ë“œ: ${towerStats[currentEra].cost}`;
      btnUpgradeTower .title = towers.length
        const nextCost = getNextUpgradeCost();
      if (nextCost > 0) {
        btnUpgradeTower.title    = `ê³¨ë“œ: ${nextCost}`;
        btnUpgradeTower.disabled = false;
      } else {
        btnUpgradeTower.title    = 'ëª¨ë“  íƒ€ì›Œ ìµœëŒ€ ë ˆë²¨';
        btnUpgradeTower.disabled = true;
      }

      skill1Btn       .title = `ê³¨ë“œ: ${skillsByEra[currentEra][0].cost}`;
      skill2Btn       .title = `ê³¨ë“œ: ${skillsByEra[currentEra][1].cost}`;
    }

    
// â”€â”€ ì „ì—­ ìƒìˆ˜ â”€â”€
const ERAS      = ['medieval','modern','future'];
const TEAMS     = ['player','enemy'];
const UNIT_TYPES= ['melee','ranged','elite','special'];

// â”€â”€ ì´ë¯¸ì§€ ë¡œë“œ í—¬í¼ â”€â”€
function loadImage(src) {
  const img = new Image();
  img.src = src;
  img.onerror = ()=> console.error(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${src}`);
  return img;
}

// â”€â”€ ìì‚° ì €ì¥ì†Œ â”€â”€
const assets = {};

// â”€â”€ ì „ì²´ ì—ì…‹ ë¡œë“œ â”€â”€
function loadAllAssets() {
  ERAS.forEach(era => {
    assets[era] = { units: {}, towers: {} };

    TEAMS.forEach(team => {
      assets[era].units[team]  = {};

      UNIT_TYPES.forEach(type => {
        // 'special' ì€ future ì‹œëŒ€ë§Œ
        if (type === 'special' && era !== 'future') return;
        if (type !== 'special' && era === 'future' && !unitTypes.future[type]) return;

        const basePath = `img/${era}/${team}/${type}`;

        // medieval: í•˜ë‚˜ì˜ ì‹œíŠ¸
        if (era === 'medieval') {
          assets[era].units[team][type] = {
            sheet: loadImage(`${basePath}/${type}_sheet.png`)
          };
        }
        // modern / future: ì• ë‹ˆë©”ì´ì…˜ë³„ ë¶„ë¦¬
        else {
          assets[era].units[team][type] = {
            Attack: loadImage(`${basePath}/Attack.png`),
            Dead:   loadImage(`${basePath}/Dead.png`),
            Idle:   loadImage(`${basePath}/Idle.png`),
            Walk:   loadImage(`${basePath}/Walk.png`)
          };
        }
      });
    });
  });
}

// ê²Œì„ ì‹œì‘ ì „ì— í•œ ë²ˆë§Œ í˜¸ì¶œ
loadAllAssets();








function gameLoop() {
  // â”€â”€ 0) ìŠ¤í‚¬ íš¨ê³¼ ë§Œë£Œ & ìƒì‚° í ì—…ë°ì´íŠ¸ â”€â”€
  const now   = performance.now();
  const delta = now - lastFrameTime;
  lastFrameTime = now;

  // 0-1) ìŠ¤í‚¬ ì´í™íŠ¸ ë§Œë£Œ ì²˜ë¦¬
  skillEffects.forEach(e => e.ttl = e.expireAt - now);
  for (let i = skillEffects.length - 1; i >= 0; i--) {
    if (skillEffects[i].ttl <= 0) skillEffects.splice(i, 1);
  }

  // 0-2) ìƒì‚° í ë‚¨ì€ ì‹œê°„ ì°¨ê°
  productionQueue.forEach(item => {
    item.remaining -= delta;
  });
  // 0-3) ì™„ë£Œëœ ê±´ ì‹¤ì œ ìœ ë‹› ìƒì„±
  while (productionQueue.length && productionQueue[0].remaining <= 0) {
    const done  = productionQueue.shift();
    const stats = unitTypes[currentEra][done.type];
    units.push(new Unit(0, 'player', done.type, stats));
  }

  // â”€â”€ 1) ìº”ë²„ìŠ¤ ì´ˆê¸°í™” â”€â”€
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // â”€â”€ 2) ê¸°ì§€ ê·¸ë¦¬ê¸° â”€â”€
  const baseWidth  = 30;
  const baseHeight = 80;
  const baseY      = canvas.height - baseHeight;
  ctx.fillStyle = 'green';
  ctx.fillRect(0, baseY, baseWidth, baseHeight);
  ctx.fillStyle = 'red';
  ctx.fillRect(canvas.width - baseWidth, baseY, baseWidth, baseHeight);

  // â”€â”€ 3) íƒ€ì›Œ ê³µê²© ë° ê·¸ë¦¬ê¸° â”€â”€
  const towerY = canvas.height - 150;
  towers.forEach(tower => {
    tower.attack(units);
    ctx.fillStyle = tower.color;
    ctx.fillRect(tower.x, towerY, 10, 50);
  });
  enemyTowers.forEach(tower => {
    tower.attack(units);
    ctx.fillStyle = tower.color;
    ctx.fillRect(tower.x, towerY, 10, 50);
  });

  // â”€â”€ 4) ìœ ë‹› ê·¸ë¦¬ê¸° & ê³µê²© ë¼ì¸ â”€â”€
  renderUnits();
  renderAttackLines();

  // â”€â”€ 5) ìœ ë‹› ì´ë™ ì „ â€œTime Warpâ€ ëŠë ¤ì§ íš¨ê³¼ ê³„ì‚° â”€â”€
  const slowActive = skillEffects.some(e => e.type === 'timeWarp');      // â”€â”€ ì¶”ê°€
  const moveFactor = slowActive ? SLOW_FACTOR : 1;                        // â”€â”€ ì¶”ê°€

  // â”€â”€ 6) ìœ ë‹› ì´ë™ Â· ê¸°ì§€ ê³µê²© Â· ì¶©ëŒ â”€â”€
  for (let i = 0; i < units.length; i++) {
    const unit = units[i];
    let blocked = false;

    // (1) Iron Wall íš¨ê³¼ê°€ ìˆìœ¼ë©´, ì  ìœ ë‹›ì€ ì¥ë²½ ì•ì—ì„œ ë©ˆì¶”ê¸° â”€â”€ ì¶”ê°€
    const wall = skillEffects.find(e => e.type === 'ironWall');
    if (wall && unit.team === 'enemy') {
      if (unit.x <= wall.x + wall.w && unit.x + 20 > wall.x) {
        blocked = true;
      }
    }

    // (2) ê¸°ì§€ ê³µê²© ë¡œì§ (ì´ë™ ê¸ˆì§€)
    if (!blocked && unit.team === 'player' && unit.x >= canvas.width - 40) {
      blocked = true;
      unit.x = canvas.width - 40;
      if (unit.baseAttackCooldown <= 0) {
        enemyBaseHp -= unit.damage;
        unit.baseAttackCooldown = 60;
      } else {
        unit.baseAttackCooldown--;
      }
    }
    if (!blocked && unit.team === 'enemy' && unit.x <= 20) {
      blocked = true;
      unit.x = 20;
      if (unit.baseAttackCooldown <= 0) {
        playerBaseHp -= unit.damage;
        unit.baseAttackCooldown = 60;
      } else {
        unit.baseAttackCooldown--;
      }
    }

    // (3) ì¼ë°˜ ê³µê²© ë° ì¶©ëŒ íŒì •
    let canMove = true;
    for (let j = 0; j < units.length; j++) {
      const other = units[j];
      if (unit === other) continue;
      if (unit.canAttack(other) && unit.cooldown <= 0) {
        unit.attack(other);
        unit.cooldown = 30;
        blocked = true;
        canMove = false;
        break;
      }
      if (unit.team !== other.team) {
        const nextX = unit.x + (unit.team === 'player' ? unit.speed : -unit.speed) * moveFactor; // â”€â”€ ìˆ˜ì •
        if (Math.abs(nextX - other.x) < 20) {
          canMove = false;
        }
      }
    }
    if (unit.cooldown > 0) unit.cooldown--;

    // (4) ì‹¤ì œ ì´ë™
    if (!blocked && canMove) {
      unit.x += (unit.team === 'player' ? unit.speed : -unit.speed) * moveFactor; // â”€â”€ ìˆ˜ì •
    }
  }

  // â”€â”€ 7) ì „íˆ¬ ì¢…ë£Œ ìœ ë‹› ì œê±° + ê²½í—˜ì¹˜/ê³¨ë“œ íšë“ + ì‹œëŒ€ ì—…ê·¸ë ˆì´ë“œ â”€â”€
  for (let i = units.length - 1; i >= 0; i--) {
    if (units[i].hp <= 0) {
      if (units[i].team === 'enemy') {
        const type = units[i].type;
        gold += goldRewardTable[type] || 20;
        exp += expTable[currentEra][type] || 0;
        tryEraUpgrade();
      }
      units.splice(i, 1);
    }
  }

  // â”€â”€ 8) HUD ê°±ì‹  â”€â”€
  updateHUD();

  // â”€â”€ 9) ìŠ¹ë¦¬/íŒ¨ë°° ì²´í¬ â”€â”€
  if (enemyBaseHp <= 0) {
    alert("ğŸ‰ ìŠ¹ë¦¬! ì  ê¸°ì§€ë¥¼ íŒŒê´´í–ˆìŠµë‹ˆë‹¤!");
    location.reload();
    return;
  }
  if (playerBaseHp <= 0) {
    alert("ğŸ’€ íŒ¨ë°°! ìš°ë¦¬ ê¸°ì§€ê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤...");
    location.reload();
    return;
  }

  // â”€â”€ 10) ë‹¤ìŒ í”„ë ˆì„ â”€â”€
  updateQueueBadges();
  requestAnimationFrame(gameLoop);
}


// ìë™ ì‹œì‘ ë¡œì§
//setDifficulty('easy');
//setInterval(() => { gold += 10; updateHUD(); }, 1000);
//gameLoop();
  function startGame(level) {
    document.getElementById('menuScreen').style.display       = 'none';
    document.getElementById('difficultyScreen').style.display = 'none';

    const hud = document.getElementById('hud');
    hud.style.display = 'flex';  // flexë¡œ ë˜ì–´ ìˆìœ¼ë©´ flex, block ì´ë©´ block

    setDifficulty(level);
    setInterval(() => { gold += 10; updateHUD(); }, 1000);
    configureSkillButtons(); 
    configureTooltips();
    gameLoop();
  }

  document.getElementById('btnPlay').addEventListener('click', () => {
    document.getElementById('menuScreen').style.display       = 'none';
    document.getElementById('difficultyScreen').style.display = 'flex';
  });

  document.querySelectorAll('#difficultyScreen .diff').forEach(btn =>
    btn.addEventListener('click', e =>
      startGame(e.currentTarget.dataset.level)
    )
  );

  document.getElementById('btnBack').addEventListener('click', e => {
    e.preventDefault();
    document.getElementById('difficultyScreen').style.display = 'none';
    document.getElementById('menuScreen').style.display       = 'flex';
  });

  </script>
</body>
</html>
